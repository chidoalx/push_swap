// void	sort_stack(t_data *arg)
// {
// 	int smallest;
// 	int index;
// 	int i;

// 	if (!is_sorted(arg->stack_a, arg->a_len))
// 	{
// 		while (arg->a_len > 3)
// 		{
// 			smallest = find_smallest(arg, arg->stack_a);
// 			index = get_index(arg, smallest);
// 			i = arg->a_len / 2;
// 			if (arg->stack_a[0] == smallest)
// 				pb(arg);
// 			if (arg->stack_a[1] == smallest)
// 				(sa(arg), pb(arg));
// 			else if (index <= i)
// 				ra(arg);
// 			else
// 				rra(arg);
// 		}
// 		sort_three(arg, arg->stack_a);
// 		while (arg->b_len != 0)
// 			pa(arg);
// 	}
// }
***************************************************************************

// void    sort_five(t_data *arg, int *stack, int i)
// {
// 	if (!is_sorted(stack, i))
// 	{
// 		while (stack[0] != find_smallest(arg, stack))
// 			ra(arg);
// 		pb(arg);
// 		while (stack[0] != find_smallest(arg, stack))
// 			ra(arg);
// 		pb(arg);
// 		sort_three(arg, stack);
// 		pa(arg);
// 		pa(arg);
// 		if (stack[0] > stack[1])
// 			sa(arg);
// 	}
// }

********************************************************************************************************

// 
// void swap(int* a, int* b)
// {
//     int temp = *a;
//     *a = *b;
//     *b = temp;
// }

// void bubbleSort(int arr[], int n)
// {
// 	int	i;
// 	int	j;

// 	i = 0;
//     while (i < n - 1)
// 	{
// 		j = 0;
//         while (j < n - i - 1)
// 		{
//             if (arr[j] > arr[j + 1]) 
//                 swap(&arr[j], &arr[j + 1]);
// 			j++;
//         }
// 		i++;
//     }
// }
// //
// int find_index(t_data *arg, int a)
// {
// 	int i;
// 	int	index;

// 	i = 0;
// 	index = 0;
// 	bubbleSort(arg->cp_tab, arg->a_len);
// 	while (i < arg->a_len)
// 	{
// 		if (i == a)
// 			index = arg->cp_tab[i];
// 		i++;
// 	}
// 	return (index);
// }

// void sort_stack(t_data *arg)
// {
//     int i;

//     if (!is_sorted(arg->stack_a, arg->a_len))
//     {
// 		while(arg->a_len != 0)
// 		{
//         	i = find_index(arg, arg->a_len / 2);
//         	while (arg->a_len >= arg->a_len / 2)
//         	{
//             	if (arg->stack_a[0] < i)
//                 	pb(arg);
//             	else if (arg->stack_a[arg->a_len - 1] < i)
//                 	rra(arg), pb(arg);
//             	else
//                 	ra(arg);
//         	}
// 		}
//     }
// }
****************************************************************************************************
int	quick_sort_b(t_stack *stack, int dim, int count_r)
{
	int	pivot;
	int	numbers;

	if (!count_r && check_sorted_desc(stack->b, dim) == 1)
		while (dim--)
			pa(stack, 1);
	if (dim <= 3)
	{
		sort_3_b(stack, dim);
		return (1);
	}
	numbers = dim;
	if (!partition(&pivot, stack->b, dim))
		return (0);
	while (dim != numbers / 2)
	{
		if (stack->b[0] >= pivot && dim--)
			pa(stack, 1);
		else if (++count_r)
			rb(stack, 1);
	}
	while (numbers / 2 != stack->len_b && count_r--)
		rrb(stack, 1);
	return (quick_sort_a(stack, numbers / 2 + numbers % 2, 0)
		&& quick_sort_b(stack, numbers / 2, 0));
}

int	quick_sort_a(t_stack *stack, int dim, int count_r)
{
	int	pivot;
	int	numbers;

	if (check_sorted_asc(stack->a, dim) == 1)
		return (1);
	numbers = dim;
	if (dim <= 3)
	{
		quick_sort_3_a_b(stack, dim);
		return (1);
	}
	if (!count_r && !partition(&pivot, stack->a, dim))
		return (0);
	while (dim != numbers / 2 + numbers % 2)
	{
		if (stack->a[0] < pivot && (dim--))
			pb(stack, 1);
		else if (++count_r)
			ra(stack, 1);
	}
	while (numbers / 2 + numbers % 2 != stack->len_a && count_r--)
		rra(stack, 1);
	return (quick_sort_a(stack, numbers / 2 + numbers % 2, 0)
		&& quick_sort_b(stack, numbers / 2, 0));
	return (1);
}
*********************************************************************************************************

void	begin_sorting(t_data *push)
{
	while (push->a_len != 0)
	{
		if (find_index(push, push->stack_a[0]) <= push->mid)
			pb(push);
		else
		{
			if (push->b_len > 1 && (find_index(push, push->stack_b[0]) < (push->mid / 2)))
				rr(push);
			else
				ra(push);
		}
	}
	push->max = push->mid;
	push->mid = (push->max - push->min) / 2 + push->min;
	push->flag++;
}

void sort_stack(t_data *arg)
{
	int small;
	int big;

	small = find_smallest(arg, arg->stack_a);
	big = find_longest(arg, arg->stack_a);
	arg->min = find_index(arg, small);
	arg->max = find_index(arg, big);
	arg->mid = arg->max / 2 + arg->min;
	arg->flag = 0;
	begin_sorting(arg);
	while (!(is_sorted(arg->stack_a, arg->a_len)))
	{
		if (arg->a_len == 0)
			pb(arg);
		else
			pa(arg);
	}

}
******************************************************************************************

int get_index(t_data *arg, int a)
{
	int i;
	int	index;

	i = 0;
	index = -1;
	while (i < arg->a_len)
	{
		if (a >= arg->stack_a[i])
			index++;
		i++;
	}
	return (index);
}
int find_index(t_data *arg, int a)
{
	int i;
	int	index;

	i = 0;
	index = 0;
	bubbleSort(arg->cp_tab, arg->a_len);
	while (i < arg->a_len)
	{
		if (i == a)
			index = arg->cp_tab[i];
		i++;
	}
	return (index);
}
***********************************************************************************************
int find_smallest(t_data *arg, int *stack)
{
	int smallest;
	int i;

	i = 1;
	smallest = stack[0];
	while (i < arg->a_len)
	{
		if (stack[i] < smallest)
			smallest = stack[i];
		i++;
	}
	return (smallest);
}

int find_longest(t_data *arg, int *stack)
{
	int longest;
	int i;

	i = 1;
	longest = stack[0];
	while (i < arg->a_len)
	{
		if (stack[i] > longest)
			longest = stack[i];
		i++;
	}
	return (longest);
}

void    sort_five(t_data *arg, int *stack, int i)
{
	if (!is_sorted(stack, i))
	{
		while (stack[0] != find_smallest(arg, stack))
			ra(arg);
		pb(arg);
		while (stack[0] != find_smallest(arg, stack))
			ra(arg);
		pb(arg);
		sort_three(arg, stack);
		pa(arg);
		pa(arg);
		if (stack[0] > stack[1])
			sa(arg);
	}
}

***********************************************************************************************